#lang racket
(require racket/match)
(require racket/random)
(require racket/list)

(define (paths)
  (cartesian-product (range 4) (range 4)))

(define (next-square-candidates coords availables)
  (match-let (((list i j) coords))
    (filter (λ (ij)
              (match ij ((list i-row j-col)
                          (or (and (equal? i i-row) (or (equal? j-col (+ j 1)) (equal? j-col (- j 1))))
                                 (and (equal? j j-col) (or (equal? i-row (+ i 1)) (equal? i-row (- i 1))))))))
            availables)))

(define (next-square coords availables)
    (random-ref (next-square-candidates coords availables)))

(define (next-squares coords availables p)
  (let ((candidates (next-square-candidates coords availables)))
    (cond ((null? candidates)  `(() ,availables))
          ((> (random) p) `(() ,availables))
          (else (let ((next (random-ref candidates)))
                  (list-next next availables .4))))))

(define (list-next next availables p)
  (match-let (((list nexts remainings) (next-squares next (remove next availables) p)))
    (list (cons next nexts) remainings)))

(define (create-path)
  (let ((squares (cartesian-product (range 4) (range 4))))
   (list-next '(0 0) squares)))

(define (create-paths availables)
  (if (null? availables)
      '()
      (match-let (((list path remainings) (list-next (car availables) availables 1) ))
        (cons path (create-paths remainings)))))
          
(define (new-logo)
  (for-each
   (λ(l) (displayln (~a "    fill whole_path("
                        (string-join (map
                                      (λ(ll) (~a "(" (string-join (map ~a ll) ", ") ")"))
                                      l)
                                     ", ") ") withcolor golden;")))
   (create-paths (cartesian-product (range 4) (range 4)) )))
