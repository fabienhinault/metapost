#lang racket
(require racket/match)
(require racket/random)
(require racket/list)
(require json)

(define (adjascent left right)
  (or (equal? left (+ right 1)) (equal? left (- right 1))))

(define (next-square-candidates current-square availables)
  (match-let (((list current-i  current-j) current-square))
    (filter (λ (available)
              (match available ((list available-i available-j)
                                (or (and (equal? current-i available-i) (adjascent available-j  current-j))
                                    (and (equal?  current-j available-j) (adjascent available-i current-i))))))
            availables)))

(define (next-square coords availables)
    (random-ref (next-square-candidates coords availables)))

(define (next-squares start-square availables continue-probability)
  (let ((candidates (next-square-candidates start-square availables)))
    (cond ((null? candidates)  `(() ,availables))
          ((> (random) continue-probability) `(() ,availables))
          (else (let ((next (random-ref candidates)))
                  (create-path-from next (remove next availables) .4))))))

(define (create-path-from first-square availables continue-probability)
  (match-let (((list nexts remainings) (next-squares first-square availables continue-probability)))
    (list (cons first-square nexts) remainings)))

(define (create-paths availables)
  (if (null? availables)
      '()
      (match-let (((list path remainings) (create-path-from (car availables) (cdr availables) 1) ))
        (cons path (create-paths remainings)))))
          
(define (new-logo)
  (for-each
   (λ(l) (displayln (~a "    fill whole_path("
                        (string-join (map
                                      (λ(ll) (~a "(" (string-join (map ~a ll) ", ") ")"))
                                      l)
                                     ", ") ") withcolor golden;")))
   (create-paths (cartesian-product (range 4) (range 4)) )))
